macs-accessories
================

The package Model-based analysis for ChIP-seq (MACS) is very useful software for peak finding on ChIP-seq data. The outputted files include peaks in BED and XLS formats and the 'tag pileup' in wiggle file format. We use macs-accessories for additional data analysis from the files including visualizations and calculations of normalized difference (NormDiff) scores from Zheng et al. (2010)

```{r setup, dev='png',cache=FALSE,echo=FALSE}
debug=FALSE
#opts_knit$set(upload.fun = imgur_upload) # upload all images to imgur.com
source('readplot.R')
source('knitr.R')
```

Typical setup preamble creates a 'wiggle class', an S3 R object and loadswiggle files based on the name parameter from MACS

```{r setup2, cache=TRUE}
wig1=WiggleClass('S96')
wig2=WiggleClass('HS959')
wig1$loadWiggles()
wig2$loadWiggles()
####
```


The normalized difference score gives us on average the expected value of the ChIP-seq subtracted from the input data using a simple random model. For $A$, $B$ representing chip-seq and input control data respectively

$A\sim Poisson(f+g)$
$B\sim Poisson(cg)$

Then the NormDiff score is defined as

$$Z=(A-B/c)/\hat\sigma$$

We use the data to estimate scaling factor $c$ and variance $\hat\sigma$ and then we can look at the distribution of average normalized difference scores for all peaks, and see how they correspond to syntenic regions in other datasets


```{r d2,dev='png',cache=TRUE}
wig1$estimateScalingFactor()  
wig1$estimateVarianceAll()   
wig2$estimateScalingFactor()   
wig2$estimateVarianceAll()
wz1=wig1$Z(wig1$peaks)
wz2=wig2$Z(wig1$peaks)
wz4=wig2$Z(wig2$peaks)
wz3=wig1$Z(wig2$peaks)
r1=plotMaxAvgZscore('Max Avg  S96 peak NormDiff score vs HS959 synteny w=100', wig1, wig2, wz1, wz2,'#bb0000', '#001199')
r2=plotMaxAvgZscore('Max Avg HS959 peak NormDiff score vs S96 synteny w=100', wig2, wig1, wz4, wz3, '#bb0000','#009900')
```



```{r zall, dev='png',cache=TRUE}
wza1=wig1$Zall()
wza2=wig2$Zall()
datasort=as.numeric(wza1[[1]][,4])
d <- density(datasort,adjust=1.2) # returns the density data
plot(d, main='Kernel density of NormDiff scores') # plots the results 
polygon(d, col="#BB2222CC", border="#222244")
clone=datasort
qqnorm(clone)
qqline(clone,col=2)
```


The NormDiff scores are the signal that we detected. We can use a conditional probability based on a correlation between the datasets to find the probability of peaks. This score is defined as

$$ p(y|x)={{P(\bar y \leq Y) corr(x,y)}\over{P(\bar x \leq X)}} $$


If we look at colored plots of the probability we get from these plots we see something like this

```{r rainbow, dev='png',warning=FALSE,cache=TRUE}

plotMaxAvgZscoreColor('S96 peaks vs HS959 synteny',wig1,wig2,wz1,wz2)
plotMaxAvgZscoreColor('HS959 vs S96 peaks colored by probability',wig2,wig1,wz4,wz3)
```


We can select the top 5 pvalues from our data to examine
```{r bedselect, cache=TRUE}
ret=plotMaxAvgZscoreColorUnique('S96 peaks vs HS959 synteny (Unique only)',wig1,wig2,wz1,wz2)
print(ret)
b1=as.numeric(ret[,1])
```

Then zooming in, we see that many of these plots have significant correlations with each other, and could possibly be called peaks. Here are some example from

```{r twilight,cache=FALSE}
bedselect=wig2$peaks[b1,]
selection1=wig1$Z(bedselect)
selection2=wig2$Z(bedselect)
reads1=wig1$getChipReads(bedselect)
reads2=wig2$getChipReads(bedselect)

plotOverlaps(b1,wig1,wig2,1,context=250)
plotOverlaps(b1,wig1,wig2,2,context=250)
plotOverlaps(b1,wig1,wig2,3,context=150)
plotOverlaps(b1,wig1,wig2,4,context=150)
```